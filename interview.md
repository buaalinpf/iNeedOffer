[toc]

### 1.关系数据库与缓存基础

#### 关系数据库：

oracle

数据库是需要支持范围查找的，而k/v不能支持。所以在查找数据方面，缓存虽然快，但是多样性上差了点。

#### key-value数据库：redis

Redis 是一个高性能的key-value非关系型数据库

单线程指的是网络请求模块使用了一个线程



redis采用多路复用机制：即多个网络socket复用一个io线程，实际是**单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流**

使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。



Redis特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。速度快，因为数据存在内存中

Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。

Redis支持数据的备份，即master-slave模式的数据备份。

性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。

原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。

丰富的特性 – Redis还支持 publish/subscribe, 通知, 设置key有效期等等特性。

定期删除：每过一定时间，随机抽取删除一些过期的key

惰性删除：当请求key时，检查他是否过期，过期则删除

allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。





### 2.常用的负载均衡策略

1.轮询

每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
upstream backserver {
server 192.168.0.14;
server 192.168.0.15;
}

2.指定权重

指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
upstream backserver {
server 192.168.0.14 weight=10;
server 192.168.0.15 weight=10;
}

3.IP绑定 ip_hash

每个请求按访问ip的hash结果分配(可以针对同一个C类地址段中的客户端选择同一个后端服务器，除非那个后端服务器宕了才会换一个)，这样每个访客固定访问一个后端服务器，可以解决session的问题。

upstream backserver {
ip_hash;
server 192.168.0.14:88;
server 192.168.0.15:80;
}

4.fair

按后端服务器的响应时间来分配请求，响应时间短的优先分配。

upstream backserver {
server server1;
server server2;
fair;
}

5.url_hash 统一资源定位符

按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
upstream backserver {
server squid1:3128;
server squid2:3128;
hash $request_uri;
hash_method crc32;
}

### 3.一致性hash实现原理



### 4.分布式一致算法(比较深入)

### 5.分布式系统主从分布

### 6.分布式事务

### 7.分布式系统基础知识

### 8.解决hash冲突

（1）线性探查法：冲突后，线性向前试探，找到最近的一个空位置。缺点是会出现堆积现象。存取时，可能不是同义词的词也位于探查序列，影响效率。   

  （2）双散列函数法：在位置d冲突后，再次使用另一个散列函数产生一个与散列表桶容量m互质的数c，依次试探(d+n*c)%m，使探查序列跳跃式分布。

### 9.先淘汰缓存

假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。

假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。

**结论：数据和缓存的操作时序：先淘汰缓存，再写数据库。**

### 10.消息队列

1.解耦 A扔到消息队列 不用频繁更新接口

2.异步 A扔到消息队列 即可继续其他的事情

3.限流 集群无法同时处理所有数据，存在消息队列，慢慢解决

### 11.五种I/O模型

**1.阻塞IO(不实用)**

阻塞式IO在进行数据读取时，上述两个阶段都会阻塞（内核等待数据，用户进程阻塞）。

在Linux中，默认所有的socket都是阻塞式的。

**2.非阻塞IO**

内核阻塞，但是用户进程并不会被阻塞，而是出错返回

然后轮询的方式，等到内核数据准备好了，则read数据

**3.信号驱动IO**

就绪条件满足时的通知方式不同。信号驱动IO是通过信号来告知，非阻塞式IO要循环使用系统调用进行轮询查看。

**4.IO多路转接**

 **IO多路转接与上述三种方式最大的不同在于它一次等待多个文件描述符，并且它将等待和数据的拷贝分隔开。**

select只负责等待，不负责拷贝

当等待的多个文件描述符中至少有一个满足就绪条件时，select返回。此时应用进程调用read（此时的套接字是阻塞的）等对数据进行拷贝。

**5.异步IO**

异步IO，应用进程提供一片缓冲区，使用特殊的系统调用aio_read。

内核没有将数据准备好时，该系统调用直接返回。进程继续做其他的事情。

此时内核等待数据，在数据到达后，**将数据拷贝到用户空间完成后**，再递交在aio_read中指定的信号，然后在对该信号进行捕捉时对数据进行处理。

信号驱动IO是在数据准备好之后通知应用进程调用相关的函数进行数据的拷贝。

而该方式是**在数据拷贝完成之后通知应用进程直接对数据进行处理。**

**同步通信和异步通信：**

**主动调用read等进行数据的拷贝，此时，在数据拷贝时进程是阻塞的。**
